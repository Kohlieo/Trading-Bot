
# rl_trader.py
# ------------
# This module implements the RLTrader class, which uses a reinforcement learning (RL) strategy to drive trading decisions. Key functionalities include:
#   - Loading a pre-trained PPO model for trade prediction
#   - Subscribing to real-time market data for selected trading symbols
#   - Buffering tick data and computing technical indicators (SMA, RSI, MACD, Bollinger Bands, ATR, etc.) using pandas_ta
#   - Predicting trading actions (BUY, SELL, HOLD) based on computed features
#   - Executing orders through the order_management module based on model predictions
#   - Enforcing trade limits and managing per-symbol trade cycles
#   - Performing online incremental training using collected daily data via a custom TradingEnv simulation
# This module is central to the autonomous trading strategy and interacts with both the IBKR API and the simulation environment.

import os
import gym
import numpy as np
import pandas as pd
import pandas_ta as ta
import logging
import math
import asyncio
import json
from datetime import datetime, timedelta
from ib_insync import Stock
from stable_baselines3 import SAC  # <-- Changed from PPO to SAC
from config import RL_MODEL_PATH, RL_SYMBOLS, MAX_SYMBOLS, MARKET_DATA_TYPE
from ibkr_connection import ibkr_client
from order_management import place_order, close_all_positions

# Import TradingEnv and load_clean_data from the Data Farm module
from trading_env import TradingEnv, load_clean_data

class RLTrader:
    def __init__(self):
        # Try to load tickers from the file generated by screener.py
        ticker_file = "/app/shared/rl_trader_tickers.json"
        try:
            if os.path.exists(ticker_file):
                with open(ticker_file, 'r') as f:
                    tickers = json.load(f)
                if tickers and len(tickers) >= 1:
                    self.symbols = tickers  # Use all provided tickers, regardless of count
                    logging.info(f"Using tickers from file: {self.symbols}")
                else:
                    logging.warning("No tickers found in file; using default RL_SYMBOLS.")
                    self.symbols = RL_SYMBOLS
            else:
                logging.warning(f"{ticker_file} not found; using default RL_SYMBOLS.")
                self.symbols = RL_SYMBOLS
        except Exception as e:
            logging.error("Error loading tickers from file: " + str(e))
            self.symbols = RL_SYMBOLS

        # Create a temporary environment instance
        env = TradingEnv(load_clean_data())

        # Load your pre-trained RL model using SAC (instead of PPO)
        self.model = SAC.load(
            RL_MODEL_PATH,
            env=env,
            custom_objects={
                "observation_space": env.observation_space,
                "action_space": env.action_space,
            }
        )

        # IMPORTANT: Correctly set the market data type (1=live, 3=delayed, etc.)
        ibkr_client.ib.reqMarketDataType(MARKET_DATA_TYPE)

        # Rolling data buffers: each symbol has a list of {"time": ..., "price": ...}
        self.price_buffers = {sym: [] for sym in self.symbols}

        # Subscribe to IBKR market data for each symbol for real-time updates
        for sym in self.symbols:
            contract = Stock(sym, 'SMART', 'USD')
            ticker = ibkr_client.ib.reqMktData(contract, '', False, False)
            # Use a lambda to capture 'sym' in the callback
            ticker.updateEvent += lambda t, s=sym: self.on_tick(t, s)

        logging.info(f"RLTrader initialized for symbols: {self.symbols}")

        # Data for online training (grouped by day)
        self.daily_data = {}
        # Flag to ensure online training runs only once per trading day
        self.trained_today = False

        # New: Per-ticker trade limitation and tracking.
        self.max_trades_per_ticker = 5  # maximum trade cycles per day per symbol
        self.trade_cycle_active = {sym: False for sym in self.symbols}
        self.trades_count = {sym: 0 for sym in self.symbols}
        self.current_trade_date = None

    def on_tick(self, ticker, symbol):
        """
        Callback fired whenever new data arrives for 'symbol'.
        We store up to 100 data points in price_buffers[symbol] and also accumulate daily data.
        """
        if ticker.last is not None:
            now = pd.Timestamp.now()
            self.price_buffers[symbol].append({
                "time": now,
                "price": ticker.last
            })
            if len(self.price_buffers[symbol]) > 100:
                self.price_buffers[symbol].pop(0)
            day = now.date()
            if day not in self.daily_data:
                self.daily_data[day] = {s: [] for s in self.symbols}
            self.daily_data[day][symbol].append({
                "time": now,
                "price": ticker.last
            })

    def compute_features(self, symbol) -> np.ndarray:
        buf = self.price_buffers[symbol]
        if len(buf) < 15:
            return np.zeros((14,), dtype=np.float32)
        df = pd.DataFrame(buf)
        df.rename(columns={'price': 'Close'}, inplace=True)
        df['Close'] = df['Close'].astype(float)
        df['Date'] = pd.to_datetime(df['time'])
        df.set_index('Date', inplace=True)
        df['Open'] = df['Close']
        df['High'] = df['Close']
        df['Low'] = df['Close']
        df['Volume'] = 1000  # Dummy volume data
        # Use forward-fill then backfill to replace missing values
        df = df.ffill().bfill()
        df.ta.sma(length=14, append=True)
        df.ta.rsi(length=14, append=True)
        try:
            df.ta.macd(append=True)
        except Exception as e:
            logging.error("Error computing MACD, defaulting MACD columns to 0.0: " + str(e))
            df['MACD_12_26_9'] = 0.0
            df['MACDs_12_26_9'] = 0.0
            df['MACDh_12_26_9'] = 0.0
        df.ta.bbands(length=20, append=True)
        df.ta.atr(length=14, append=True)
        df['Returns'] = df['Close'].pct_change()
        df['Volatility'] = df['Returns'].rolling(window=14).std() * np.sqrt(14)
        df['AvgVolume'] = df['Volume'].rolling(window=14).mean()
        df['RelativeVolume'] = df['Volume'] / df['AvgVolume']
        df = df.fillna(0)
        latest = df.iloc[-1]
        bbm = latest['BBM_20_2.0'] if 'BBM_20_2.0' in latest.index else latest['Close']
        bbu = latest['BBU_20_2.0'] if 'BBU_20_2.0' in latest.index else latest['Close']
        bbl = latest['BBL_20_2.0'] if 'BBL_20_2.0' in latest.index else latest['Close']
        macd = latest['MACD_12_26_9'] if 'MACD_12_26_9' in latest.index else 0.0
        macds = latest['MACDs_12_26_9'] if 'MACDs_12_26_9' in latest.index else 0.0
        macdh = latest['MACDh_12_26_9'] if 'MACDh_12_26_9' in latest.index else 0.0
        atr = latest['ATR_14'] if 'ATR_14' in latest.index else 0.0
        features = np.array([
            latest['Close'],
            latest['SMA_14'],
            latest['RSI_14'],
            bbm,
            bbu,
            bbl,
            macd,
            macds,
            macdh,
            atr,
            latest['Returns'],
            latest['Volatility'],
            latest['AvgVolume'],
            latest['RelativeVolume']
        ], dtype=np.float32)
        features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
        return features

    async def fetch_historical_ticks(self, symbol, num_ticks=100):
        """
        Fetch the last `num_ticks` ticks for a given symbol using IBKR's historical ticks API.
        """
        from ib_insync import Stock
        contract = Stock(symbol, "SMART", "USD")
        ibkr_client.ib.qualifyContracts(contract)
        end_dt = datetime.utcnow()
        start_dt = end_dt - timedelta(minutes=10)
        ticks = await ibkr_client.ib.reqHistoricalTicksAsync(
            contract,
            startDateTime=start_dt.strftime("%Y%m%d-%H:%M:%S"),
            endDateTime=end_dt.strftime("%Y%m%d-%H:%M:%S"),
            numberOfTicks=num_ticks,
            whatToShow='TRADES',
            useRth=False
        )
        tick_buffer = []
        for tick in ticks:
            tick_buffer.append({
                "time": tick.time,
                "price": tick.price
            })
        return tick_buffer

    async def run(self):
        # Initialize the last ticker refresh time
        self.last_ticker_refresh = datetime.utcnow()

        # Pre-populate tick buffers using historical ticks for each symbol
        for sym in self.symbols:
            try:
                historical_ticks = await self.fetch_historical_ticks(sym, num_ticks=100)
                if historical_ticks:
                    self.price_buffers[sym] = historical_ticks[-15:] if len(historical_ticks) >= 15 else historical_ticks
                    logging.info(f"Pre-populated tick buffer for {sym} with {len(self.price_buffers[sym])} ticks.")
                else:
                    logging.warning(f"No historical ticks available for {sym}; waiting for live ticks to accumulate.")
            except Exception as e:
                logging.error(f"Failed to fetch historical ticks for {sym}: {e}", exc_info=True)
        logging.info("RLTrader main loop started.")
        last_action = {}
        while True:
            await ibkr_client.ensure_connection()
            ibkr_client.ib.waitOnUpdate(timeout=1)
            current_utc = datetime.utcnow()
            current_pst = current_utc - timedelta(hours=8)
            
            # Check if it's a new trading day and reset counters if so
            if self.current_trade_date != current_pst.date():
                self.current_trade_date = current_pst.date()
                for sym in self.symbols:
                    self.trades_count[sym] = 0
                    self.trade_cycle_active[sym] = False
                logging.info(f"New trading day (PST): {self.current_trade_date}. Reset trade counters.")

            # === Periodically refresh ticker list every 3 minutes ===
            if (current_utc - self.last_ticker_refresh).total_seconds() >= 60:
                self.last_ticker_refresh = current_utc
                ticker_file = "/app/shared/rl_trader_tickers.json"
                try:
                    if os.path.exists(ticker_file):
                        with open(ticker_file, 'r') as f:
                            new_tickers = json.load(f)
                        if not new_tickers or len(new_tickers) < 1:
                            logging.warning("Ticker file is empty or invalid; using current symbols.")
                            new_tickers = self.symbols
                    else:
                        logging.warning(f"{ticker_file} not found; retaining current symbols.")
                        new_tickers = self.symbols
                except Exception as e:
                    logging.error("Error reloading tickers from file: " + str(e))
                    new_tickers = self.symbols

                # Determine symbols to remove (present in current list but not in new_tickers)
                removed_symbols = [sym for sym in self.symbols if sym not in new_tickers]
                for sym in removed_symbols:
                    logging.info(f"Symbol {sym} no longer in ticker list. Exiting any open position.")
                    try:
                        tick_size = await ibkr_client.get_tick_size(sym)
                    except Exception as e:
                        logging.error(f"Could not get tick size for {sym}: {e}")
                        tick_size = 0.01  # Fallback tick size
                    # Use latest available price from price buffer if available
                    if self.price_buffers.get(sym) and len(self.price_buffers[sym]) > 0:
                        latest_price = self.price_buffers[sym][-1]['price']
                    else:
                        latest_price = None
                    if latest_price is not None:
                        asyncio.create_task(close_all_positions(sym, tick_size, latest_price))
                    # Remove symbol from internal dictionaries
                    self.price_buffers.pop(sym, None)
                    self.trade_cycle_active.pop(sym, None)
                    self.trades_count.pop(sym, None)
                
                # Update internal symbols and add new symbols if needed
                for sym in new_tickers:
                    if sym not in self.price_buffers:
                        self.price_buffers[sym] = []
                    if sym not in self.trade_cycle_active:
                        self.trade_cycle_active[sym] = False
                    if sym not in self.trades_count:
                        self.trades_count[sym] = 0
                self.symbols = new_tickers
                logging.info(f"Updated ticker list: {self.symbols}")
            # === End of ticker refresh logic ===

            # Trading logic for each symbol
            for symbol in self.symbols:
                if current_pst.hour < 1 or current_pst.hour >= 15:
                    logging.info(f"[RLTrader] {symbol}: Outside allowed trading window (PST {current_pst.hour}). Skipping trade.")
                    continue
                if self.trades_count[symbol] >= self.max_trades_per_ticker:
                    logging.info(f"[RLTrader] {symbol}: Reached maximum trade count for today. Skipping trade.")
                    continue
                if len(self.price_buffers[symbol]) < 15:
                    logging.info(f"[RLTrader] {symbol}: Insufficient tick data ({len(self.price_buffers[symbol])} ticks). Waiting for 15 ticks.")
                    continue
                obs = self.compute_features(symbol)
                if obs.shape != (14,):
                    logging.error(f"Unexpected observation shape for {symbol}: {obs.shape}")
                    continue
                action, _ = self.model.predict(obs, deterministic=True)
                if action == 1:
                    if not self.trade_cycle_active[symbol]:
                        logging.info(f"[RLTrader] {symbol}: RL indicates BUY.")
                        asyncio.create_task(place_order(symbol, "BUY"))
                        self.trade_cycle_active[symbol] = True
                    else:
                        logging.info(f"[RLTrader] {symbol}: Active trade already in progress. Skipping BUY.")
                elif action == 2:
                    if self.trade_cycle_active[symbol]:
                        logging.info(f"[RLTrader] {symbol}: RL indicates SELL.")
                        asyncio.create_task(place_order(symbol, "SELL"))
                        self.trade_cycle_active[symbol] = False
                        self.trades_count[symbol] += 1
                    else:
                        logging.info(f"[RLTrader] {symbol}: No active trade to sell. Skipping SELL.")
                last_action[symbol] = action

            await asyncio.sleep(1)


    async def online_train(self):
        """
        Use the data collected over the trading day to simulate an episode
        with the TradingEnv, and perform incremental training.
        """
        previous_day = datetime.utcnow().date() - timedelta(days=1)
        if previous_day not in self.daily_data:
            logging.info("No training data available for previous day.")
            return
        symbol = self.symbols[0]
        data = self.daily_data[previous_day][symbol]
        if len(data) < 20:
            logging.info("Not enough data for training.")
            return
        df = pd.DataFrame(data)
        df.rename(columns={'price': 'Close'}, inplace=True)
        df['DateTime'] = pd.to_datetime(df['time'])
        df['Volume'] = 1000
        df.sort_values('DateTime', inplace=True)
        env = TradingEnv(df)
        logging.info(f"Starting online training for day: {previous_day}")
        self.model.learn(total_timesteps=500)
        # Persist the updated model to disk
        self.model.save(RL_MODEL_PATH)
        logging.info(f"Completed online training for day: {previous_day}")
        del self.daily_data[previous_day]

if __name__ == "__main__":
    trader = RLTrader()
    asyncio.run(trader.run())

